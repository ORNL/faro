// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: faro/proto/face_service.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "faro/proto/FaceService.pbobjc.h"
#import "faro/proto/Image.pbobjc.h"
#import "faro/proto/Geometry.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - FaceServiceRoot

@implementation FaceServiceRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - FaceServiceRoot_FileDescriptor

static GPBFileDescriptor *FaceServiceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ServiceStatus

GPBEnumDescriptor *ServiceStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Ready\000Error\000Busy\000";
    static const int32_t values[] = {
        ServiceStatus_Unknown,
        ServiceStatus_Ready,
        ServiceStatus_Error,
        ServiceStatus_Busy,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ServiceStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ServiceStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ServiceStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case ServiceStatus_Unknown:
    case ServiceStatus_Ready:
    case ServiceStatus_Error:
    case ServiceStatus_Busy:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum DataType

GPBEnumDescriptor *DataType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Empty\000String\000Int\000Float\000Bytes\000Vector\000Pick"
        "le\000Xml\000Json\000";
    static const int32_t values[] = {
        DataType_Empty,
        DataType_String,
        DataType_Int,
        DataType_Float,
        DataType_Bytes,
        DataType_Vector,
        DataType_Pickle,
        DataType_Xml,
        DataType_Json,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(DataType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:DataType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL DataType_IsValidValue(int32_t value__) {
  switch (value__) {
    case DataType_Empty:
    case DataType_String:
    case DataType_Int:
    case DataType_Float:
    case DataType_Bytes:
    case DataType_Vector:
    case DataType_Pickle:
    case DataType_Xml:
    case DataType_Json:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ScoreType

GPBEnumDescriptor *ScoreType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Server\000L1\000L2\000NegDot\000";
    static const int32_t values[] = {
        ScoreType_Server,
        ScoreType_L1,
        ScoreType_L2,
        ScoreType_NegDot,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ScoreType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ScoreType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ScoreType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ScoreType_Server:
    case ScoreType_L1:
    case ScoreType_L2:
    case ScoreType_NegDot:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Attribute

@implementation Attribute

@dynamic key;
@dynamic description_p;
@dynamic buffer;
@dynamic fvalue;
@dynamic ivalue;
@dynamic text;
@dynamic pickle;
@dynamic json;
@dynamic hasMatrix, matrix;
@dynamic hasVector, vector;
@dynamic hasImage, image;
@dynamic hasPoint, point;
@dynamic hasRect, rect;
@dynamic xml;

typedef struct Attribute__storage_ {
  uint32_t _has_storage_[1];
  float fvalue;
  int32_t ivalue;
  NSString *key;
  NSString *description_p;
  NSData *buffer;
  NSString *text;
  NSData *pickle;
  NSData *json;
  Matrix *matrix;
  Vector *vector;
  Image *image;
  Point2D *point;
  Rect_Class *rect;
  NSData *xml;
} Attribute__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Attribute__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Description_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Attribute__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Buffer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Attribute__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fvalue",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Fvalue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Attribute__storage_, fvalue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "ivalue",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Ivalue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Attribute__storage_, ivalue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Text,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Attribute__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pickle",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Pickle,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Attribute__storage_, pickle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "json",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Json,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Attribute__storage_, json),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "matrix",
        .dataTypeSpecific.className = GPBStringifySymbol(Matrix),
        .number = Attribute_FieldNumber_Matrix,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Attribute__storage_, matrix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "vector",
        .dataTypeSpecific.className = GPBStringifySymbol(Vector),
        .number = Attribute_FieldNumber_Vector,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Attribute__storage_, vector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = Attribute_FieldNumber_Image,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Attribute__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "point",
        .dataTypeSpecific.className = GPBStringifySymbol(Point2D),
        .number = Attribute_FieldNumber_Point,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Attribute__storage_, point),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rect",
        .dataTypeSpecific.className = GPBStringifySymbol(Rect_Class),
        .number = Attribute_FieldNumber_Rect,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Attribute__storage_, rect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "xml",
        .dataTypeSpecific.className = NULL,
        .number = Attribute_FieldNumber_Xml,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Attribute__storage_, xml),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Attribute class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Attribute__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ErrorMessage

@implementation ErrorMessage

@dynamic errorCode;
@dynamic errorMessage;

typedef struct ErrorMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t errorCode;
  NSString *errorMessage;
} ErrorMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = ErrorMessage_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ErrorMessage__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.className = NULL,
        .number = ErrorMessage_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ErrorMessage__storage_, errorMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ErrorMessage class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ErrorMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Detection

@implementation Detection

@dynamic score;
@dynamic hasLocation, location;
@dynamic detectionId;
@dynamic detectionClass;
@dynamic attributesArray, attributesArray_Count;

typedef struct Detection__storage_ {
  uint32_t _has_storage_[1];
  float score;
  int32_t detectionId;
  Rect_Class *location;
  NSString *detectionClass;
  NSMutableArray *attributesArray;
} Detection__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = Detection_FieldNumber_Score,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Detection__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(Rect_Class),
        .number = Detection_FieldNumber_Location,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Detection__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detectionId",
        .dataTypeSpecific.className = NULL,
        .number = Detection_FieldNumber_DetectionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Detection__storage_, detectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detectionClass",
        .dataTypeSpecific.className = NULL,
        .number = Detection_FieldNumber_DetectionClass,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Detection__storage_, detectionClass),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = Detection_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Detection__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Detection class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Detection__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Landmark

@implementation Landmark

@dynamic landmarkId;
@dynamic hasLocation, location;

typedef struct Landmark__storage_ {
  uint32_t _has_storage_[1];
  NSString *landmarkId;
  Point2D *location;
} Landmark__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "landmarkId",
        .dataTypeSpecific.className = NULL,
        .number = Landmark_FieldNumber_LandmarkId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Landmark__storage_, landmarkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(Point2D),
        .number = Landmark_FieldNumber_Location,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Landmark__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Landmark class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Landmark__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectionOptions

@implementation DetectionOptions

@dynamic algorithmId;
@dynamic best;
@dynamic threshold;
@dynamic scaleLevels;
@dynamic scanLevels;
@dynamic scanOverlap;
@dynamic minSize;
@dynamic attributesArray, attributesArray_Count;

typedef struct DetectionOptions__storage_ {
  uint32_t _has_storage_[1];
  float threshold;
  int32_t scaleLevels;
  int32_t scanLevels;
  float scanOverlap;
  int32_t minSize;
  NSString *algorithmId;
  NSMutableArray *attributesArray;
} DetectionOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "algorithmId",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_AlgorithmId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, algorithmId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "best",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_Best,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_Threshold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "scaleLevels",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_ScaleLevels,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, scaleLevels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scanLevels",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_ScanLevels,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, scanLevels),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "scanOverlap",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_ScanOverlap,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, scanOverlap),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "minSize",
        .dataTypeSpecific.className = NULL,
        .number = DetectionOptions_FieldNumber_MinSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, minSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = DetectionOptions_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DetectionOptions__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectionOptions class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectionOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtractOptions

@implementation ExtractOptions

@dynamic algorithmId;
@dynamic attributesArray, attributesArray_Count;

typedef struct ExtractOptions__storage_ {
  uint32_t _has_storage_[1];
  NSString *algorithmId;
  NSMutableArray *attributesArray;
} ExtractOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "algorithmId",
        .dataTypeSpecific.className = NULL,
        .number = ExtractOptions_FieldNumber_AlgorithmId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtractOptions__storage_, algorithmId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = ExtractOptions_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ExtractOptions__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExtractOptions class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtractOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollOptions

@implementation EnrollOptions

@dynamic attributesArray, attributesArray_Count;

typedef struct EnrollOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *attributesArray;
} EnrollOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = EnrollOptions_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EnrollOptions__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollOptions class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectionList

@implementation DetectionList

@dynamic detectionsArray, detectionsArray_Count;
@dynamic detectionTime;
@dynamic imageWidth;
@dynamic imageHeight;
@dynamic detectionCount;
@dynamic hasOptions, options;

typedef struct DetectionList__storage_ {
  uint32_t _has_storage_[1];
  float detectionTime;
  int32_t imageWidth;
  int32_t imageHeight;
  int32_t detectionCount;
  NSMutableArray *detectionsArray;
  DetectionOptions *options;
} DetectionList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detectionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Detection),
        .number = DetectionList_FieldNumber_DetectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DetectionList__storage_, detectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detectionTime",
        .dataTypeSpecific.className = NULL,
        .number = DetectionList_FieldNumber_DetectionTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectionList__storage_, detectionTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "imageWidth",
        .dataTypeSpecific.className = NULL,
        .number = DetectionList_FieldNumber_ImageWidth,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetectionList__storage_, imageWidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imageHeight",
        .dataTypeSpecific.className = NULL,
        .number = DetectionList_FieldNumber_ImageHeight,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetectionList__storage_, imageHeight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detectionCount",
        .dataTypeSpecific.className = NULL,
        .number = DetectionList_FieldNumber_DetectionCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DetectionList__storage_, detectionCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(DetectionOptions),
        .number = DetectionList_FieldNumber_Options,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DetectionList__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectionList class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectionList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchList

@implementation MatchList

@dynamic matchListArray, matchListArray_Count;

typedef struct MatchList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *matchListArray;
} MatchList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "matchListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MatchInfo),
        .number = MatchList_FieldNumber_MatchListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MatchList__storage_, matchListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchList class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MatchInfo

@implementation MatchInfo

@dynamic score;
@dynamic imageId;
@dynamic detectionId;
@dynamic subjectId;
@dynamic subjectName;
@dynamic hasFace, face;

typedef struct MatchInfo__storage_ {
  uint32_t _has_storage_[1];
  float score;
  NSString *imageId;
  NSString *detectionId;
  NSString *subjectId;
  NSString *subjectName;
  Image *face;
} MatchInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = MatchInfo_FieldNumber_Score,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "imageId",
        .dataTypeSpecific.className = NULL,
        .number = MatchInfo_FieldNumber_ImageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, imageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detectionId",
        .dataTypeSpecific.className = NULL,
        .number = MatchInfo_FieldNumber_DetectionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, detectionId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = MatchInfo_FieldNumber_SubjectId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectName",
        .dataTypeSpecific.className = NULL,
        .number = MatchInfo_FieldNumber_SubjectName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, subjectName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "face",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = MatchInfo_FieldNumber_Face,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MatchInfo__storage_, face),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MatchInfo class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MatchInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TemplateInput

@implementation TemplateInput

@dynamic hasIm, im;
@dynamic detectionsArray, detectionsArray_Count;

typedef struct TemplateInput__storage_ {
  uint32_t _has_storage_[1];
  Image *im;
  NSMutableArray *detectionsArray;
} TemplateInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "im",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = TemplateInput_FieldNumber_Im,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TemplateInput__storage_, im),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detectionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Rect_Class),
        .number = TemplateInput_FieldNumber_DetectionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TemplateInput__storage_, detectionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TemplateInput class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TemplateInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceTemplate

@implementation FaceTemplate

@dynamic hasData_p, data_p;
@dynamic buffer;

typedef struct FaceTemplate__storage_ {
  uint32_t _has_storage_[1];
  Vector *data_p;
  NSData *buffer;
} FaceTemplate__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(Vector),
        .number = FaceTemplate_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FaceTemplate__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = FaceTemplate_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FaceTemplate__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceTemplate class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceTemplate__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TemplateList

@implementation TemplateList

@dynamic templatesArray, templatesArray_Count;

typedef struct TemplateList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *templatesArray;
} TemplateList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "templatesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceTemplate),
        .number = TemplateList_FieldNumber_TemplatesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TemplateList__storage_, templatesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TemplateList class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TemplateList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AccessRecord

@implementation AccessRecord

@dynamic datetime;
@dynamic notes;
@dynamic credential;
@dynamic metadataArray, metadataArray_Count;

typedef struct AccessRecord__storage_ {
  uint32_t _has_storage_[1];
  float datetime;
  NSString *notes;
  NSString *credential;
  NSMutableArray *metadataArray;
} AccessRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "datetime",
        .dataTypeSpecific.className = NULL,
        .number = AccessRecord_FieldNumber_Datetime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccessRecord__storage_, datetime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "notes",
        .dataTypeSpecific.className = NULL,
        .number = AccessRecord_FieldNumber_Notes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccessRecord__storage_, notes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "credential",
        .dataTypeSpecific.className = NULL,
        .number = AccessRecord_FieldNumber_Credential,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AccessRecord__storage_, credential),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "metadataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = AccessRecord_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AccessRecord__storage_, metadataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccessRecord class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccessRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceRecord

@implementation FaceRecord

@dynamic subjectId;
@dynamic name;
@dynamic source;
@dynamic frame;
@dynamic notes;
@dynamic galleryKey;
@dynamic collectionDate;
@dynamic enrollmentDate;
@dynamic metadataArray, metadataArray_Count;
@dynamic accessRecordsArray, accessRecordsArray_Count;
@dynamic hasView, view;
@dynamic hasAligned, aligned;
@dynamic hasDetection, detection;
@dynamic landmarksArray, landmarksArray_Count;
@dynamic attributesArray, attributesArray_Count;
@dynamic internalDataArray, internalDataArray_Count;
@dynamic hasTemplate_p, template_p;
@dynamic score;
@dynamic hasSearchResults, searchResults;

typedef struct FaceRecord__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float collectionDate;
  float enrollmentDate;
  NSString *subjectId;
  Detection *detection;
  FaceTemplate *template_p;
  NSString *source;
  NSString *name;
  NSString *notes;
  Image *view;
  NSMutableArray *landmarksArray;
  Image *aligned;
  NSMutableArray *attributesArray;
  NSMutableArray *internalDataArray;
  FaceRecordList *searchResults;
  NSString *galleryKey;
  NSMutableArray *metadataArray;
  NSMutableArray *accessRecordsArray;
  int64_t frame;
} FaceRecord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_SubjectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detection",
        .dataTypeSpecific.className = GPBStringifySymbol(Detection),
        .number = FaceRecord_FieldNumber_Detection,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, detection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "template_p",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceTemplate),
        .number = FaceRecord_FieldNumber_Template_p,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, template_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notes",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_Notes,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, notes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "view",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = FaceRecord_FieldNumber_View,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, view),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "landmarksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Landmark),
        .number = FaceRecord_FieldNumber_LandmarksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, landmarksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aligned",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = FaceRecord_FieldNumber_Aligned,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, aligned),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attributesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = FaceRecord_FieldNumber_AttributesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, attributesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "internalDataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = FaceRecord_FieldNumber_InternalDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, internalDataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_Score,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "searchResults",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = FaceRecord_FieldNumber_SearchResults,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, searchResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_Frame,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "galleryKey",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_GalleryKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, galleryKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "collectionDate",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_CollectionDate,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, collectionDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "enrollmentDate",
        .dataTypeSpecific.className = NULL,
        .number = FaceRecord_FieldNumber_EnrollmentDate,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, enrollmentDate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "metadataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Attribute),
        .number = FaceRecord_FieldNumber_MetadataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, metadataArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accessRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AccessRecord),
        .number = FaceRecord_FieldNumber_AccessRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecord__storage_, accessRecordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceRecord class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceRecord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceRecordList

@implementation FaceRecordList

@dynamic faceRecordsArray, faceRecordsArray_Count;

typedef struct FaceRecordList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *faceRecordsArray;
} FaceRecordList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "faceRecordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecord),
        .number = FaceRecordList_FieldNumber_FaceRecordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FaceRecordList__storage_, faceRecordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceRecordList class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceRecordList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerificationRequest

@implementation VerificationRequest

@dynamic gallery;
@dynamic subjectId;
@dynamic faceRecordArray, faceRecordArray_Count;

typedef struct VerificationRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *gallery;
  NSString *subjectId;
  NSMutableArray *faceRecordArray;
} VerificationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gallery",
        .dataTypeSpecific.className = NULL,
        .number = VerificationRequest_FieldNumber_Gallery,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerificationRequest__storage_, gallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = VerificationRequest_FieldNumber_SubjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerificationRequest__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceRecordArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecord),
        .number = VerificationRequest_FieldNumber_FaceRecordArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerificationRequest__storage_, faceRecordArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerificationRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerificationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerificationResponse

@implementation VerificationResponse

@dynamic errorCode;
@dynamic errorMessage;
@dynamic success;
@dynamic confidence;
@dynamic matchesArray, matchesArray_Count;

typedef struct VerificationResponse__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  int32_t errorCode;
  NSMutableArray *matchesArray;
  NSString *errorMessage;
} VerificationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = VerificationResponse_FieldNumber_Success,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = VerificationResponse_FieldNumber_Confidence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VerificationResponse__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "matchesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecord),
        .number = VerificationResponse_FieldNumber_MatchesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerificationResponse__storage_, matchesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = VerificationResponse_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerificationResponse__storage_, errorCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.className = NULL,
        .number = VerificationResponse_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerificationResponse__storage_, errorMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerificationResponse class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerificationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchRequest

@implementation SearchRequest

@dynamic searchGallery;
@dynamic hasProbes, probes;
@dynamic maxResults;
@dynamic threshold;

typedef struct SearchRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxResults;
  float threshold;
  NSString *searchGallery;
  FaceRecordList *probes;
} SearchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "searchGallery",
        .dataTypeSpecific.className = NULL,
        .number = SearchRequest_FieldNumber_SearchGallery,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchRequest__storage_, searchGallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "probes",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = SearchRequest_FieldNumber_Probes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchRequest__storage_, probes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxResults",
        .dataTypeSpecific.className = NULL,
        .number = SearchRequest_FieldNumber_MaxResults,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SearchRequest__storage_, maxResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = SearchRequest_FieldNumber_Threshold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SearchRequest__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SearchResponse

@implementation SearchResponse

@dynamic hasMessage, message;
@dynamic hasProbes, probes;

typedef struct SearchResponse__storage_ {
  uint32_t _has_storage_[1];
  ErrorMessage *message;
  FaceRecordList *probes;
} SearchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = GPBStringifySymbol(ErrorMessage),
        .number = SearchResponse_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SearchResponse__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "probes",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = SearchResponse_FieldNumber_Probes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SearchResponse__storage_, probes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SearchResponse class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SearchResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollRequest

@implementation EnrollRequest

@dynamic enrollGallery;
@dynamic hasRecords, records;
@dynamic hasEnrollOptions, enrollOptions;

typedef struct EnrollRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *enrollGallery;
  FaceRecordList *records;
  EnrollOptions *enrollOptions;
} EnrollRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enrollGallery",
        .dataTypeSpecific.className = NULL,
        .number = EnrollRequest_FieldNumber_EnrollGallery,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnrollRequest__storage_, enrollGallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "records",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = EnrollRequest_FieldNumber_Records,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnrollRequest__storage_, records),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enrollOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(EnrollOptions),
        .number = EnrollRequest_FieldNumber_EnrollOptions,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EnrollRequest__storage_, enrollOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectRequest

@implementation DetectRequest

@dynamic hasImage, image;
@dynamic source;
@dynamic frame;
@dynamic subjectId;
@dynamic subjectName;
@dynamic hasDetectOptions, detectOptions;

typedef struct DetectRequest__storage_ {
  uint32_t _has_storage_[1];
  Image *image;
  NSString *source;
  NSString *subjectId;
  NSString *subjectName;
  DetectionOptions *detectOptions;
  int64_t frame;
} DetectRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = DetectRequest_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = DetectRequest_FieldNumber_Source,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "frame",
        .dataTypeSpecific.className = NULL,
        .number = DetectRequest_FieldNumber_Frame,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, frame),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = DetectRequest_FieldNumber_SubjectId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectName",
        .dataTypeSpecific.className = NULL,
        .number = DetectRequest_FieldNumber_SubjectName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, subjectName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "detectOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(DetectionOptions),
        .number = DetectRequest_FieldNumber_DetectOptions,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DetectRequest__storage_, detectOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtractRequest

@implementation ExtractRequest

@dynamic hasImage, image;
@dynamic hasRecords, records;
@dynamic hasExtractOptions, extractOptions;

typedef struct ExtractRequest__storage_ {
  uint32_t _has_storage_[1];
  Image *image;
  FaceRecordList *records;
  ExtractOptions *extractOptions;
} ExtractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(Image),
        .number = ExtractRequest_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtractRequest__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "records",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = ExtractRequest_FieldNumber_Records,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtractRequest__storage_, records),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extractOptions",
        .dataTypeSpecific.className = GPBStringifySymbol(ExtractOptions),
        .number = ExtractRequest_FieldNumber_ExtractOptions,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtractRequest__storage_, extractOptions),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExtractRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtractRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScoreRequest

@implementation ScoreRequest

@dynamic hasFaceProbes, faceProbes;
@dynamic hasFaceGallery, faceGallery;
@dynamic hasTemplateProbes, templateProbes;
@dynamic hasTemplateGallery, templateGallery;

typedef struct ScoreRequest__storage_ {
  uint32_t _has_storage_[1];
  FaceRecordList *faceProbes;
  FaceRecordList *faceGallery;
  TemplateList *templateProbes;
  TemplateList *templateGallery;
} ScoreRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "faceProbes",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = ScoreRequest_FieldNumber_FaceProbes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScoreRequest__storage_, faceProbes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "faceGallery",
        .dataTypeSpecific.className = GPBStringifySymbol(FaceRecordList),
        .number = ScoreRequest_FieldNumber_FaceGallery,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScoreRequest__storage_, faceGallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "templateProbes",
        .dataTypeSpecific.className = GPBStringifySymbol(TemplateList),
        .number = ScoreRequest_FieldNumber_TemplateProbes,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScoreRequest__storage_, templateProbes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "templateGallery",
        .dataTypeSpecific.className = GPBStringifySymbol(TemplateList),
        .number = ScoreRequest_FieldNumber_TemplateGallery,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScoreRequest__storage_, templateGallery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScoreRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScoreRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectExtractRequest

@implementation DetectExtractRequest

@dynamic hasDetectRequest, detectRequest;
@dynamic hasExtractRequest, extractRequest;

typedef struct DetectExtractRequest__storage_ {
  uint32_t _has_storage_[1];
  DetectRequest *detectRequest;
  ExtractRequest *extractRequest;
} DetectExtractRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detectRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(DetectRequest),
        .number = DetectExtractRequest_FieldNumber_DetectRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectExtractRequest__storage_, detectRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extractRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ExtractRequest),
        .number = DetectExtractRequest_FieldNumber_ExtractRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetectExtractRequest__storage_, extractRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectExtractRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectExtractRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectExtractEnrollRequest

@implementation DetectExtractEnrollRequest

@dynamic hasDetectRequest, detectRequest;
@dynamic hasExtractRequest, extractRequest;
@dynamic hasEnrollRequest, enrollRequest;

typedef struct DetectExtractEnrollRequest__storage_ {
  uint32_t _has_storage_[1];
  DetectRequest *detectRequest;
  ExtractRequest *extractRequest;
  EnrollRequest *enrollRequest;
} DetectExtractEnrollRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detectRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(DetectRequest),
        .number = DetectExtractEnrollRequest_FieldNumber_DetectRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectExtractEnrollRequest__storage_, detectRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extractRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ExtractRequest),
        .number = DetectExtractEnrollRequest_FieldNumber_ExtractRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetectExtractEnrollRequest__storage_, extractRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enrollRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(EnrollRequest),
        .number = DetectExtractEnrollRequest_FieldNumber_EnrollRequest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetectExtractEnrollRequest__storage_, enrollRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectExtractEnrollRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectExtractEnrollRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DetectExtractSearchRequest

@implementation DetectExtractSearchRequest

@dynamic hasDetectRequest, detectRequest;
@dynamic hasExtractRequest, extractRequest;
@dynamic hasSearchRequest, searchRequest;

typedef struct DetectExtractSearchRequest__storage_ {
  uint32_t _has_storage_[1];
  DetectRequest *detectRequest;
  ExtractRequest *extractRequest;
  SearchRequest *searchRequest;
} DetectExtractSearchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detectRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(DetectRequest),
        .number = DetectExtractSearchRequest_FieldNumber_DetectRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DetectExtractSearchRequest__storage_, detectRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extractRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(ExtractRequest),
        .number = DetectExtractSearchRequest_FieldNumber_ExtractRequest,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DetectExtractSearchRequest__storage_, extractRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "searchRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(SearchRequest),
        .number = DetectExtractSearchRequest_FieldNumber_SearchRequest,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DetectExtractSearchRequest__storage_, searchRequest),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DetectExtractSearchRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DetectExtractSearchRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceStatusRequest

@implementation FaceStatusRequest


typedef struct FaceStatusRequest__storage_ {
  uint32_t _has_storage_[1];
} FaceStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceStatusRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(FaceStatusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceServiceInfo

@implementation FaceServiceInfo

@dynamic status;
@dynamic workerCount;
@dynamic detectionSupport;
@dynamic extractSupport;
@dynamic scoreSupport;
@dynamic attributeSupport;
@dynamic scoreType;
@dynamic detectionThreshold;
@dynamic matchThreshold;
@dynamic algorithm;
@dynamic notes;

typedef struct FaceServiceInfo__storage_ {
  uint32_t _has_storage_[1];
  ServiceStatus status;
  int32_t workerCount;
  ScoreType scoreType;
  float detectionThreshold;
  float matchThreshold;
  NSString *algorithm;
  NSString *notes;
} FaceServiceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = ServiceStatus_EnumDescriptor,
        .number = FaceServiceInfo_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "workerCount",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_WorkerCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, workerCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "detectionSupport",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_DetectionSupport,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "extractSupport",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_ExtractSupport,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "scoreSupport",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_ScoreSupport,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "attributeSupport",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_AttributeSupport,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "scoreType",
        .dataTypeSpecific.enumDescFunc = ScoreType_EnumDescriptor,
        .number = FaceServiceInfo_FieldNumber_ScoreType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, scoreType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "detectionThreshold",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_DetectionThreshold,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, detectionThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "matchThreshold",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_MatchThreshold,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, matchThreshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "algorithm",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_Algorithm,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, algorithm),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notes",
        .dataTypeSpecific.className = NULL,
        .number = FaceServiceInfo_FieldNumber_Notes,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(FaceServiceInfo__storage_, notes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceServiceInfo class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceServiceInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t FaceServiceInfo_Status_RawValue(FaceServiceInfo *message) {
  GPBDescriptor *descriptor = [FaceServiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceServiceInfo_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceServiceInfo_Status_RawValue(FaceServiceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceServiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceServiceInfo_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t FaceServiceInfo_ScoreType_RawValue(FaceServiceInfo *message) {
  GPBDescriptor *descriptor = [FaceServiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceServiceInfo_FieldNumber_ScoreType];
  return GPBGetMessageInt32Field(message, field);
}

void SetFaceServiceInfo_ScoreType_RawValue(FaceServiceInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [FaceServiceInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:FaceServiceInfo_FieldNumber_ScoreType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GalleryListRequest

@implementation GalleryListRequest


typedef struct GalleryListRequest__storage_ {
  uint32_t _has_storage_[1];
} GalleryListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GalleryListRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GalleryListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GalleryDeleteRequest

@implementation GalleryDeleteRequest

@dynamic galleryName;

typedef struct GalleryDeleteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *galleryName;
} GalleryDeleteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleryName",
        .dataTypeSpecific.className = NULL,
        .number = GalleryDeleteRequest_FieldNumber_GalleryName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GalleryDeleteRequest__storage_, galleryName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GalleryDeleteRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GalleryDeleteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollmentListRequest

@implementation EnrollmentListRequest

@dynamic galleryName;

typedef struct EnrollmentListRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *galleryName;
} EnrollmentListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleryName",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentListRequest_FieldNumber_GalleryName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnrollmentListRequest__storage_, galleryName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollmentListRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollmentListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollmentInfo

@implementation EnrollmentInfo

@dynamic subjectId;
@dynamic name;
@dynamic faceCount;

typedef struct EnrollmentInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t faceCount;
  NSString *subjectId;
  NSString *name;
} EnrollmentInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentInfo_FieldNumber_SubjectId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnrollmentInfo__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnrollmentInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceCount",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentInfo_FieldNumber_FaceCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EnrollmentInfo__storage_, faceCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollmentInfo class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollmentInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollmentListResponse

@implementation EnrollmentListResponse

@dynamic galleryName;
@dynamic enrollmentsArray, enrollmentsArray_Count;

typedef struct EnrollmentListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *galleryName;
  NSMutableArray *enrollmentsArray;
} EnrollmentListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleryName",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentListResponse_FieldNumber_GalleryName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnrollmentListResponse__storage_, galleryName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "enrollmentsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EnrollmentInfo),
        .number = EnrollmentListResponse_FieldNumber_EnrollmentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EnrollmentListResponse__storage_, enrollmentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollmentListResponse class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollmentListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnrollmentDeleteRequest

@implementation EnrollmentDeleteRequest

@dynamic galleryName;
@dynamic subjectId;

typedef struct EnrollmentDeleteRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *galleryName;
  NSString *subjectId;
} EnrollmentDeleteRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleryName",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentDeleteRequest_FieldNumber_GalleryName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnrollmentDeleteRequest__storage_, galleryName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "subjectId",
        .dataTypeSpecific.className = NULL,
        .number = EnrollmentDeleteRequest_FieldNumber_SubjectId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnrollmentDeleteRequest__storage_, subjectId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnrollmentDeleteRequest class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnrollmentDeleteRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GalleryInfo

@implementation GalleryInfo

@dynamic galleryName;
@dynamic faceCount;

typedef struct GalleryInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *galleryName;
  int64_t faceCount;
} GalleryInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleryName",
        .dataTypeSpecific.className = NULL,
        .number = GalleryInfo_FieldNumber_GalleryName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GalleryInfo__storage_, galleryName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "faceCount",
        .dataTypeSpecific.className = NULL,
        .number = GalleryInfo_FieldNumber_FaceCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GalleryInfo__storage_, faceCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GalleryInfo class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GalleryInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GalleryList

@implementation GalleryList

@dynamic galleriesArray, galleriesArray_Count;

typedef struct GalleryList__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *galleriesArray;
} GalleryList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "galleriesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GalleryInfo),
        .number = GalleryList_FieldNumber_GalleriesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GalleryList__storage_, galleriesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GalleryList class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GalleryList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[FaceServiceRoot class]
                                          file:FaceServiceRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
